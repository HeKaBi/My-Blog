# 栈和队列专题

------



## Leetcode 232.用栈实现队列

解题关键:

设立一个进栈Stin和出栈Stout，in是用来实现push这个接口，out用来实现pop（将in的元素压入out，这样子就模拟了队列的pop）也用来实现front（用新pop重载，然后push）。empty就是判断in和out是否同时为空。

------



## Leetcode 225.用队列实现栈

解题关键:

这道题可以用一个队列去模拟，设立size去统计栈的元素，当pop时，就将size-1个元素push到队尾，top也是同理（用新pop函数重载，最后在push此元素到队尾）。empty就不说了

------



## Leetcode 20.有效括号

解题关键:

1.分析三种不匹配的情况：左括号多了，右括号多了，括号数量对但是不匹配.

2.将左括号对应的右括号压入栈中，遇到相应右括号，比较top元素是否一致，一致就弹出

3.如果空栈还有要匹配的右括号和不空栈和不匹配都是错误的，只有没有要匹配的右括号并且空栈才是对的。

------



## Leetcode 1047.删除字符串中的所有相邻重复项

解题关键：

用栈，一个个压入，并且与top匹配，如果与top相等，就弹出top，并且不压入此元素。最后将栈元素录入字符串，再将字符串反转。

------



## Leetcode 150.逆波兰表达式求值

解题关键：

遇到数字压入栈，遇到运算符，将两个数字弹出栈，计算，再压入栈。 注意字符串怎么判断是否为数字，并且将字符串转化为十进制数字。

------



## Leetcode 239.滑动窗口最大值

解题关键

1.用单调队列(deque实现)，pop(int val)的操作是遇到相同的val才弹出，push(int val)的操作是与队列back的元素比较，弹出比val小的元素，push val进去，front就是返回首个元素

2.首先储存前k个的最大值，并且把最大值储存到结果vector，然后从k+1个开始压入，把第一个pop出

------



## Leetcode 347.前K个高频元素

解题关键

1.设立compare类做优先队列priority_queue的compare，compare是左边.second>右边.second（小顶堆）

2.设立map去存储key（值）和val（频率）。

3.设立iterator，遍历map，装入que，因为是小顶堆，大于k个就弹出

3.设立vector<pair<int,int>>，从后往前加入，（因为要求从大到小的顺序）
